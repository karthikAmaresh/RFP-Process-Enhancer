"""
HTTP-based Orchestrator - Coordinates RFP analysis agents via HTTP calls
Supports both local agents and Azure Container Apps deployment
"""
import os
import httpx
import asyncio
from typing import Dict, Optional
from memory.short_term_memory import ShortTermMemory

# Configuration - Set these URLs after deploying to Azure Container Apps
# Agent names use underscores internally but Container App names use hyphens
AGENT_URLS = {
    "introduction": os.getenv("AGENT_URL_INTRODUCTION", "http://localhost:8001"),
    "challenges": os.getenv("AGENT_URL_CHALLENGES", "http://localhost:8002"),
    "pain_points": os.getenv("AGENT_URL_PAIN_POINTS", "http://localhost:8003"),
    "business_process": os.getenv("AGENT_URL_BUSINESS_PROCESS", "http://localhost:8004"),
    "gap": os.getenv("AGENT_URL_GAP", "http://localhost:8005"),
    "personas": os.getenv("AGENT_URL_PERSONAS", "http://localhost:8006"),
    "constraints": os.getenv("AGENT_URL_CONSTRAINTS", "http://localhost:8007"),
    "functional_requirements": os.getenv("AGENT_URL_FUNCTIONAL_REQUIREMENTS", "http://localhost:8008"),
    "nfr": os.getenv("AGENT_URL_NFR", "http://localhost:8009"),
    "architecture": os.getenv("AGENT_URL_ARCHITECTURE", "http://localhost:8010"),
    "assumptions": os.getenv("AGENT_URL_ASSUMPTIONS", "http://localhost:8011"),
    "impact": os.getenv("AGENT_URL_IMPACT", "http://localhost:8012"),
}

# Timeout configuration (agents can take 30+ seconds)
TIMEOUT = httpx.Timeout(120.0, connect=10.0)

async def call_agent(agent_name: str, text: str, context: Dict = None, client: httpx.AsyncClient = None) -> str:
    """
    Call a single agent via HTTP.
    
    Args:
        agent_name: Name of the agent to call
        text: RFP text to analyze
        context: Optional context from previous agents
        client: HTTP client to use
        
    Returns:
        str: Analysis result from agent
    """
    url = AGENT_URLS.get(agent_name)
    if not url:
        raise ValueError(f"No URL configured for agent: {agent_name}")
    
    payload = {
        "text": text,
        "context": context or {}
    }
    
    try:
        print(f"  • Calling {agent_name} agent at {url}...")
        response = await client.post(f"{url}/analyze", json=payload, timeout=TIMEOUT)
        response.raise_for_status()
        
        result = response.json()
        return result.get("result", "")
    except httpx.HTTPError as e:
        print(f"  ✗ Error calling {agent_name}: {str(e)}")
        return f"Error: {str(e)}"

async def run_all_agents_async(text: str) -> dict:
    """
    Run all 12 RFP analysis agents asynchronously via HTTP.
    
    Args:
        text: RFP document text to analyze
        
    Returns:
        dict: All agent outputs {agent_name: analysis_result}
    """
    memory = ShortTermMemory()
    results = {}
    
    async with httpx.AsyncClient(timeout=TIMEOUT) as client:
        # Run agents in order (some depend on previous results)
        agent_order = [
            "introduction",
            "challenges",
            "pain_points",
            "business_process",
            "gap",
            "personas",
            "constraints",
            "functional_requirements",
            "nfr",
            "architecture",
            "assumptions",
            "impact",
        ]
        
        for agent_name in agent_order:
            # Get context from previous agents
            context = memory.get_all()
            
            # Call agent
            result = await call_agent(agent_name, text, context, client)
            
            # Store result
            memory.add(agent_name, result)
            results[agent_name] = result
    
    return results

async def run_all_agents(text: str) -> dict:
    """
    Async agent execution that can be called from FastAPI.
    
    Args:
        text: RFP document text to analyze
        
    Returns:
        dict: All agent outputs {agent_name: analysis_result}
    """
    return await run_all_agents_async(text)

def save_to_kb(memory_output: dict, output_file: str = "kb.md"):
    """
    Save agent analysis results to structured knowledge base file.
    
    Args:
        memory_output: Dict of agent results
        output_file: Output filename (default: kb.md)
    """
    with open(output_file, "w", encoding="utf-8") as f:
        # Header
        f.write("# Knowledge Base for RFP Analysis\n\n")
        f.write("*Generated by RFP Process Enhancer - AI Agent System*\n\n")
        f.write("---\n\n")
        
        # 1. Introduction (from introduction agent)
        if "introduction" in memory_output:
            f.write(memory_output["introduction"] + "\n\n")
            f.write("---\n\n")
        
        # 2. Requirements Section
        f.write("## 2. Requirements\n\n")
        
        # 2.1 Challenges
        if "challenges" in memory_output:
            f.write(memory_output["challenges"] + "\n\n")
        
        # 2.2 User Pain Points
        if "pain_points" in memory_output:
            f.write(memory_output["pain_points"] + "\n\n")
        
        # 2.3 Current Business Process
        if "business_process" in memory_output:
            f.write(memory_output["business_process"] + "\n\n")
        
        # 2.4 Gap Analysis
        if "gap" in memory_output:
            f.write(memory_output["gap"] + "\n\n")
        
        # 2.5 Personas
        if "personas" in memory_output:
            f.write(memory_output["personas"] + "\n\n")
        
        # 2.6 Constraints
        if "constraints" in memory_output:
            f.write(memory_output["constraints"] + "\n\n")
        
        # 2.7 Functional Requirements
        if "functional_requirements" in memory_output:
            f.write(memory_output["functional_requirements"] + "\n\n")
        
        # 2.8 Non-Functional Requirements
        if "nfr" in memory_output:
            f.write(memory_output["nfr"] + "\n\n")
        
        f.write("---\n\n")
        
        # 3. Solutioning Section
        f.write("## 3. Solutioning\n\n")
        
        # 3.1 Architecture (comprehensive from architect agent)
        if "architecture" in memory_output:
            f.write(memory_output["architecture"] + "\n\n")
        
        f.write("---\n\n")
        
        # 4. Assumptions and Dependencies
        if "assumptions" in memory_output:
            f.write(memory_output["assumptions"] + "\n\n")
        
        f.write("---\n\n")
        
        # Appendix: Impact Statements (supporting information)
        if "impact" in memory_output:
            f.write("## Appendix: Impactful Business Statements\n\n")
            f.write("*This section contains key metrics, compliance requirements, and strategic statements extracted from the RFP.*\n\n")
            f.write(memory_output["impact"] + "\n\n")

if __name__ == "__main__":
    # Test with sample text
    import sys
    
    if len(sys.argv) > 1:
        # Read from file
        with open(sys.argv[1], "r") as f:
            text = f.read()
    else:
        # Test text
        text = "This is a test RFP for inventory management system using IoT sensors."
    
    print("Running agents via HTTP...")
    results = run_all_agents(text)
    
    print("\n=== All Agent Results ===")
    for agent_name, output in results.items():
        print(f"\n--- {agent_name.upper()} ---")
        print(output[:200] + "..." if len(output) > 200 else output)
    
    # Save to knowledge base
    save_to_kb(results)
    print("\n✓ Results saved to kb.md")
