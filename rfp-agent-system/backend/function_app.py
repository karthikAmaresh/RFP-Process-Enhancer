"""
Azure Functions App - RFP Process Enhancer
Serverless deployment of AI agents
"""
import azure.functions as func
import logging
import json
import tempfile
import os
from pathlib import Path

# Create function app
app = func.FunctionApp()

def generate_kb_content(results: dict) -> str:
    """Generate markdown KB content from agent results"""
    kb = "# RFP Analysis Knowledge Base\n\nGenerated by RFP Process Enhancer - AI Agent System\n\n---\n\n"
    
    section_titles = {
        "business_process": "BUSINESS PROCESS",
        "gap": "GAP",
        "personas": "PERSONAS",
        "pain_points": "PAIN POINTS",
        "impact": "IMPACT",
        "challenges": "CHALLENGES",
        "nfr": "NFR",
        "architecture": "ARCHITECTURE",
        "constraints": "CONSTRAINTS",
        "assumptions": "ASSUMPTIONS"
    }
    
    for key, title in section_titles.items():
        if key in results:
            kb += f"## {title}\n\n{results[key]}\n\n---\n\n"
    
    return kb

@app.route(route="health", methods=["GET"], auth_level=func.AuthLevel.ANONYMOUS)
def health_check(req: func.HttpRequest) -> func.HttpResponse:
    """Health check endpoint"""
    logging.info('Health check requested')
    return func.HttpResponse(
        json.dumps({"status": "healthy", "service": "RFP Process Enhancer"}),
        mimetype="application/json",
        status_code=200
    )


@app.route(route="process", methods=["POST"], auth_level=func.AuthLevel.ANONYMOUS)
def process_rfp(req: func.HttpRequest) -> func.HttpResponse:
    """
    Process RFP document through AI agents
    
    Expected input:
    - Multipart form with 'file' field (PDF)
    OR
    - JSON with 'blob_name' field (Azure Blob reference)
    """
    logging.info('Processing RFP request received')
    
    try:
        # Check if file uploaded
        file = req.files.get('file')
        
        if file:
            # Save uploaded file temporarily
            with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
                file_content = file.read()
                tmp_file.write(file_content)
                tmp_path = tmp_file.name
            
            try:
                # Import here to avoid cold start issues
                from pipeline import process_rfp_document
                from orchestrator import save_to_kb
                
                # Process the document
                results = process_rfp_document(file_path=tmp_path)
                
                # Generate KB content from results
                kb_content = generate_kb_content(results)
                
                return func.HttpResponse(
                    json.dumps({
                        "success": True,
                        "message": "RFP processed successfully",
                        "output": kb_content,
                        "results": results,
                        "storage_location": "Azure Functions"
                    }),
                    mimetype="application/json",
                    status_code=200
                )
                
            finally:
                # Cleanup temp file
                if os.path.exists(tmp_path):
                    os.remove(tmp_path)
        
        # Check for blob_name in request body
        try:
            req_body = req.get_json()
            blob_name = req_body.get('blob_name')
            
            if blob_name:
                from pipeline import process_rfp_document
                
                # Process from blob
                results = process_rfp_document(blob_name=blob_name)
                
                # Read generated KB
                kb_path = Path(__file__).parent / "data/context/kb.md"
                if kb_path.exists():
                    with open(kb_path, 'r', encoding='utf-8') as f:
                        kb_content = f.read()
                else:
                    kb_content = "Knowledge base not generated"
                
                return func.HttpResponse(
                    json.dumps({
                        "success": True,
                        "message": "RFP processed successfully",
                        "blob_name": blob_name,
                        "output": kb_content,
                        "storage_location": "Azure Blob Storage"
                    }),
                    mimetype="application/json",
                    status_code=200
                )
        except:
            pass
        
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "error": "No file or blob_name provided"
            }),
            mimetype="application/json",
            status_code=400
        )
        
    except Exception as e:
        logging.error(f"Error processing RFP: {str(e)}", exc_info=True)
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "error": str(e)
            }),
            mimetype="application/json",
            status_code=500
        )


@app.route(route="agents/{agent_name}", methods=["POST"], auth_level=func.AuthLevel.FUNCTION)
def run_single_agent(req: func.HttpRequest) -> func.HttpResponse:
    """
    Run a single agent on provided text
    
    URL: /api/agents/{agent_name}
    Body: {"text": "RFP text to analyze"}
    
    Available agents:
    - introduction
    - challenges
    - pain_points
    - business_process
    - gap
    - personas
    - constraints
    - functional_requirements
    - nfr
    - architecture
    - assumptions
    - impact
    """
    logging.info('Single agent execution requested')
    
    try:
        agent_name = req.route_params.get('agent_name')
        req_body = req.get_json()
        text = req_body.get('text')
        
        if not text:
            return func.HttpResponse(
                json.dumps({"success": False, "error": "Text required"}),
                mimetype="application/json",
                status_code=400
            )
        
        # Import agent classes
        from agents.introduction_agent import IntroductionAgent
        from agents.challenge_agent import ChallengesAgent
        from agents.pain_point_agent import PainPointsAgent
        from agents.business_process_agent import BusinessProcessAgent
        from agents.gap_agent import GapAgent
        from agents.persona_agent import PersonaAgent
        from agents.constraints_agent import ConstraintsAgent
        from agents.functional_requirements_agent import FunctionalRequirementsAgent
        from agents.nfr_agent import NFRAgent
        from agents.architect_agent import ArchitectAgent
        from agents.assumptions_agent import AssumptionsAgent
        from agents.impact_agent import ImpactfulStatementsAgent
        from llm_client import LLMClient
        
        # Map agent names to classes
        agent_map = {
            "introduction": IntroductionAgent,
            "challenges": ChallengesAgent,
            "pain_points": PainPointsAgent,
            "business_process": BusinessProcessAgent,
            "gap": GapAgent,
            "personas": PersonaAgent,
            "constraints": ConstraintsAgent,
            "functional_requirements": FunctionalRequirementsAgent,
            "nfr": NFRAgent,
            "architecture": ArchitectAgent,
            "assumptions": AssumptionsAgent,
            "impact": ImpactfulStatementsAgent
        }
        
        if agent_name not in agent_map:
            return func.HttpResponse(
                json.dumps({
                    "success": False,
                    "error": f"Unknown agent: {agent_name}",
                    "available_agents": list(agent_map.keys())
                }),
                mimetype="application/json",
                status_code=400
            )
        
        # Load prompt template
        prompt_path = Path(__file__).parent / "prompts" / f"{agent_name}.txt"
        if not prompt_path.exists():
            return func.HttpResponse(
                json.dumps({
                    "success": False,
                    "error": f"Prompt template not found for {agent_name}"
                }),
                mimetype="application/json",
                status_code=500
            )
        
        with open(prompt_path, 'r', encoding='utf-8') as f:
            prompt_template = f.read()
        
        # Initialize LLM and agent
        llm_client = LLMClient()
        agent_class = agent_map[agent_name]
        agent = agent_class(llm_client.generate, prompt_template)
        
        # Run agent
        result = agent.extract(text)
        
        # Get usage stats
        stats = llm_client.get_usage_stats()
        
        return func.HttpResponse(
            json.dumps({
                "success": True,
                "agent": agent_name,
                "result": result,
                "usage": stats
            }),
            mimetype="application/json",
            status_code=200
        )
        
    except Exception as e:
        logging.error(f"Error running agent: {str(e)}", exc_info=True)
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "error": str(e)
            }),
            mimetype="application/json",
            status_code=500
        )


@app.route(route="kb", methods=["GET"], auth_level=func.AuthLevel.ANONYMOUS)
def get_knowledge_base(req: func.HttpRequest) -> func.HttpResponse:
    """Get the current knowledge base content"""
    logging.info('Knowledge base retrieval requested')
    
    try:
        kb_path = Path(__file__).parent / "data/context/kb.md"
        
        if not kb_path.exists():
            return func.HttpResponse(
                json.dumps({
                    "success": False,
                    "error": "Knowledge base not found"
                }),
                mimetype="application/json",
                status_code=404
            )
        
        with open(kb_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        return func.HttpResponse(
            json.dumps({
                "success": True,
                "content": content
            }),
            mimetype="application/json",
            status_code=200
        )
        
    except Exception as e:
        logging.error(f"Error retrieving KB: {str(e)}", exc_info=True)
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "error": str(e)
            }),
            mimetype="application/json",
            status_code=500
        )
